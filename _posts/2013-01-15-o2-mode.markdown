---
layout: post
title: "Webruby updates: the new optimization mode and minor API changes"
date: 2013-01-15 20:50
comments: true
categories: webruby mruby JavaScript
---
Now here's some exciting news(at least exciting for me): with all the optimizations from emscripten and closure compiler, now the generated JavaScript file is only ~800k with ruby parser code, or ~400k without parser code!

This means that with only a JavaScript of ~400k, you can have a full-fledged Ruby running in the browser! Personally I think this really brings webruby to a usable state, what do you think?

To enable this optimization, instead of running `rake`, you can simple run the following command:

{% highlight bash %}
$ OPT=1 rake
{% endhighlight %}

On my machine, the generated JavaScript file here is only 821k. Or if you do not need the parser code, you can further strip the file size with:

{% highlight bash %}
$ LOADING_MODE=0 OPT=1 rake
{% endhighlight %}

My test shows that the file size has been further reduced to only 401k!

Notice that now the linking time is longer than the normal case, so I suggest you only use optimization mode only when releasing your code, and continue with the non-optimization option when developing.

There's also a small API changes from what I described in the [tutorial](/2013/01/09/webruby-1-2-3-tutorial). Now the HTMl skeleton for invoking webruby looks like following:

{% highlight html %}
<!DOCTYPE html>
<html>
  <head>
    <title>Webruby tutorial</title>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script src="webruby.js"></script>
  </head>
  <body>
    <h1>This is a skeleton for Webruby tutorial!</h1>
    <div id="container"></div>
    <script>
      $(document).ready(function() {
        var src = "MrubyJs.get_root_object.call('$', '#container')" +
          ".call('append', '<p>This is inserted in Webruby using " +
          "run_source()!</p>')";

        var w = WEBRUBY();

        /* Runs embedded source code in mruby.js file. */
        w.run();

        /* Parses and executes Ruby source code on the fly. */
        w.run_source(src);

        /* Closes this webruby instance and frees all resources,
         * this may be optional, but it will help reduce memory
         * usage if you have multiple webruby instances in your
         * page.
         */
        w.close();
      });
    </script>
  </body>
</html>
{% endhighlight %}

Now `WEBRUBY` serves as a function instead of an object. With each run of `WEBRUBY()`, you can have a separate webruby instance for running Ruby code. The mruby state, `mrb`, is now encapsulated in the returned object of `WEBRUBY()`. You do not need to specify it manually now.

Personally, I think this new API is a little simpler. However, if you have other opinions, please feel free to leave a comment here:)
