<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Xuejie Xiao's playground]]></title>
  <link href="http://xxuejie.github.com/atom.xml" rel="self"/>
  <link href="http://xxuejie.github.com/"/>
  <updated>2012-12-17T20:57:34-05:00</updated>
  <id>http://xxuejie.github.com/</id>
  <author>
    <name><![CDATA[Xuejie Xiao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[It's official: mruby-browser is now called WebRuby!]]></title>
    <link href="http://xxuejie.github.com/blog/2012/12/11/mruby-browser-is-now-called-webruby/"/>
    <updated>2012-12-11T15:32:00-05:00</updated>
    <id>http://xxuejie.github.com/blog/2012/12/11/mruby-browser-is-now-called-webruby</id>
    <content type="html"><![CDATA[<p>After a pretty long <a href="https://github.com/kripken/emscripten/issues/747">discussion and fix</a>(Thanks to <a href="https://github.com/kripken">Alon</a> for the awesome job in fixing this issue!), now <code>setjmp/longjmp</code> in <code>emscripten</code> works well. The C++ dependency in <code>mruby-browser</code> can be finally dropped, and all the mruby tests can pass without any particular hack. We can now say that the basic building block is there, and I can turn to focus on more interesting stuffs. It is also at this time that I think a new meaningful name is needed for this project. The original <code>mruby-browser</code> sounds too much like an experiment instead of a project for everyone to use.</p>

<p>The first thing came to my mind is <code>RubyScript</code>. With something already built called <code>CoffeeScript</code> or <code>ClojureScript</code>, it is not so hard for this particular name to come to my mind. However, Google tells us that someone has already uses this <a href="https://github.com/judofyr/rubyscript">name</a>. It looks quite like a hackathon project(20 commits in two days, and no commits since then for over a year). But I still do not want to take the risk that this guy(or lady, it is so hard for me to judge this by the name, can anyone give me a hint?) may want to bring this project back to life. Let&#8217;s try something else.</p>

<p>What&#8217;s worth mentioning is that someone is building <a href="http://mobiruby.org/">MobiRuby</a>, which brings mruby to iOS. Well, I&#8217;m bringing mruby to the Web, so what about <code>WebRuby</code>? Google tells us that there aren&#8217;t so many people using this name, <a href="https://github.com/SatishTalim/webruby">one</a> is using this as a repository for a web <a href="http://rubylearning.org/">course</a>, while the <a href="https://github.com/socialshift/web-ruby">other</a> is just a sinatra-based web backend. Well, I will just pick this one as the name:)</p>

<p>Besides changing the name, I also change the build script a little bit. Now we can simply put mruby source code in <code>src</code> folder, the source code will be parsed and compiled when building the project. Only the final generated bytecode will be included in the js file or the webpage. This saves us the time for parsing the source code online. If at some point we need to parse the mruby source code online, we can easily bring this back since the parse code is still included in the generated <code>js</code> code.</p>

<p>Personally, one good thing about owning an open source project is that you can decide the priority of each feature:) As a developer who always dream about creating games, my next thing to work on will be a wrapper for <code>OpenGL ES 2.0</code> API. I still haven&#8217;t thought of some beautiful ideas on a calling interface between mruby and c(or js), so I think I will first focus on some particular library wrappers. Since <a href="http://mruby.sh/201212101231.html">mrbgems</a> is already in HEAD, it becomes a natural idea to pack this library as a mrbgem. The reason for choosing <code>OpenGL ES 2.0</code> over <code>WebGL</code> is that <code>OpenGL ES 2.0</code> is more general, and maybe it can also be used with <code>mruby</code> in iOS or Android development. What&#8217;s more, <code>emscripten</code> provides a translation between <code>OpenGL ES 2.0</code> and <code>WebGL</code>, so we can simply take advantage of that instead of write yet another wrapper of <code>WebGL</code>.</p>

<p>Just as I said before, it is really fun working on this:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Make mruby tests pass in a browser]]></title>
    <link href="http://xxuejie.github.com/blog/2012/11/22/make-mruby-tests-pass-in-a-browser/"/>
    <updated>2012-11-22T12:22:00-05:00</updated>
    <id>http://xxuejie.github.com/blog/2012/11/22/make-mruby-tests-pass-in-a-browser</id>
    <content type="html"><![CDATA[<p>With my Hadoop paper submitted last Friday, I can spend more time playing with mruby. Now after several days&#8217; hacking, I finally manage to make all mruby tests pass in a browser or in node.js.</p>

<div>
  <pre><code class='bash'>$ make test
make[2]: Nothing to be done for `all'.
make[2]: Nothing to be done for `all'.
make[2]: Nothing to be done for `all'.
make[2]: Nothing to be done for `all'.
Running mruby test in Node.js!
node ./build/mruby-test.js
mrbtest - Embeddable Ruby Test

This is a very early version, please test and report errors.
Thanks :)

......................................................................................
......................................................................................
......................................................................................
......................................................................................
......................................................................................
.............................................................
Total: 491
   OK: 491
   KO: 0
Crash: 0
 Time: 1.999 seconds</code></pre>
</div>


<p>Now it&#8217;s time to keep a note on how to make these tests passed.</p>

<p>As this <a href="https://github.com/kripken/emscripten/issues/705">Issue</a> is resolved(Thanks to Alon Zakai for his super fast commit to fix this!), the mruby source code can be compiled using <code>emcc</code> successfully, the sample <code>main.c</code> file also works. But there are still 5 tests left that are not passed: 2 of them failed, while the other 3 caused node.js to crash. These 5 tests are:</p>

<ul>
<li>Tests for <code>erf</code> and <code>erfc</code> functions in <code>math.rb</code></li>
<li><code>Float#round [15.2.9.3.12]</code> in <code>float.rb</code></li>
<li><code>String#to_f [15.2.10.5.39]</code> in <code>string.rb</code></li>
<li><code>Exception 14</code> in <code>exception.rb</code></li>
<li><code>Proc.new [15.2.17.3.1]</code> in <code>proc.rb</code></li>
</ul>


<p>To be honest, the result is quite good, since only 5 of the 489 tests got problems. I guess <code>emscripten</code> really has reached a pretty mature status thanks to Alon. Most of the fixes here are resolved from commits to <code>mruby</code> or <code>emscripten</code> directly. However, there are also annoying ones. Anyway, I will explain how to make each of them pass.</p>

<h2><code>erf</code> and <code>erfc</code> functions</h2>

<p>Honestly, this is the first time that I heard about these two functions. They reside in the <code>math.h</code> header file of standard C library. The <code>erf</code> function is used to calculate the error function of a value <code>x</code>. While the &#8216;erfc&#8217; function calculates the complementary error function of <code>x</code>. <code>emscripten</code> does not come with an implementation for this function. However, there is an implementation in <code>math.c</code> of <code>mruby</code> for MSVC, which does not provide <code>erf/erfc</code> functions. It was originally take from <a href="http://www.digitalmars.com/archives/cplusplus/3634.html">here</a>:</p>

<div>
  <pre><code class='c'>double
erf(double x)
{
  static const double two_sqrtpi =  1.128379167095512574;
  double sum  = x;
  double term = x;
  double xsqr = x*x;
  int j= 1;
  if (fabs(x) &gt; 2.2) {
    return 1.0 - erfc(x);
  }
  do {
    term *= xsqr/j;
    sum  -= term/(2*j+1);
    ++j;
    term *= xsqr/j;
    sum  += term/(2*j+1);
    ++j;
  } while (fabs(term/sum) &gt; MATH_TOLERANCE);
  return two_sqrtpi*sum;
}</code></pre>
</div>


<p>What&#8217;s worth noting is that the original <code>mruby</code> implementation contains a bug which will give wrong results for negative values. The original post from digitalmars also has a fix for this problem. It was just the case that the original commiter uses the earlier version without the fix. Hence a simple <a href="https://github.com/mruby/mruby/commit/f7dd27a92827af91aa52c78bfbf96d5f7e73c4bd">commit</a> to the <code>mruby</code> project solved this problem. A similar <a href="https://github.com/kripken/emscripten/commit/9be35831f0741070e495622e6c7ba51fbbb6475c">version</a> in JavaScript could also be implemented, the <code>erf/erfc</code> test would then pass.</p>

<h2><code>Fload#round</code> test</h2>

<p>This is an interesting and easy one. The test code resides at <a href="https://github.com/mruby/mruby/blob/master/test/t/float.rb#L96">here</a>. Actually all the round tests give the correct result, what went the wrong is that <code>==</code> is used to test equality for two floating point values. A small <a href="https://github.com/mruby/mruby/commit/a9c8ae49ebe1c54b93dcffa46370d4099e0c7ea3">commit</a> fixes this, easy one.</p>

<h2><code>String#to_f</code> test</h2>

<p>This is also related floating point value. The code is at <a href="https://github.com/mruby/mruby/blob/master/test/t/string.rb#L325">here</a>. <code>b</code> should be assigned to <code>123456789.0</code>, when using <code>check_float</code> to compare <code>b</code> with <code>123456789.0</code>, they should be treated as equality. Funny thing is that node.js would give the result of <code>1.4901161193848e-08</code> as the difference between the two values, while <code>check_float</code> would only consider two values to be the same if they are within <code>1E-12</code>.</p>

<p>Simply changing Line #328 to <code>123456789</code> instead of <code>123456789.0</code> would give the correct result, but this is a very bad fix for this problem and does not really solve it. Basically there may be two reasons:</p>

<ol>
<li>Somewhere in the generated JavaScript code of <code>emscripten</code>, the code does not treat the floating point value well.</li>
<li><code>v8</code> does not provide that many precisions for floating point value.</li>
</ol>


<p>It is still unknown which is the cause for this problem. What I choose to do now is to let <code>mruby</code> use float instead of double. When using float, <code>check_float</code> would accept two values within <code>1E-5</code>, for which the current result of <code>1.4901161193848e-08</code> will be enough. Anyway, I will come back to this later, maybe a dig into the <code>v8</code> issue list can bring some insight into this.</p>

<h2><code>Exception 14</code> and <code>Proc.new [15.2.17.3.1]</code></h2>

<p>Both the <a href="https://github.com/mruby/mruby/blob/master/test/t/exception.rb#L261">exception</a> and <a href="https://github.com/mruby/mruby/blob/master/test/t/proc.rb#L12">proc</a> tests crash <code>node.js</code>, and they both use a <code>begin ... rescue ... end</code> statement with a method call in the <code>begin</code> clause. A simple guess is that they are due to the same reason.</p>

<p>I spent a whole day debugging this problem by inserting debug statements in mruby source code, reading generated logs as well as JavaScript source code written in assembly style. The <code>LABEL_DEBUG</code> option in <code>emscripten</code> proves to be a huge help here(thanks again, Alon!). Finally the problem turns out to be the need for stack manipulation setjmp/longjmp. I prepared a <a href="https://gist.github.com/4128331">gist</a> describing this problem:</p>

<div>
  <pre><code class='c'>#include &lt;setjmp.h&gt;
#include &lt;stdio.h&gt;

typedef struct {
  jmp_buf* jmp;
} jmp_state;

void stack_manipulate_func(jmp_state* s, int level) {
  jmp_buf buf;

  printf(&quot;Entering stack_manipulate_func, level: %d\n&quot;, level);

  if (level == 0) {
    s-&gt;jmp = &amp;buf;
    if (setjmp(*(s-&gt;jmp)) == 0) {
      printf(&quot;Setjmp normal execution path, level: %d\n&quot;, level);
      stack_manipulate_func(s, level + 1);
    } else {
      printf(&quot;Setjmp error execution path, level: %d\n&quot;, level);
    }
  } else {
    printf(&quot;Perform longjmp at level %d\n&quot;, level);
    longjmp(*(s-&gt;jmp), 1);
  }

  printf(&quot;Exiting stack_manipulate_func, level: %d\n&quot;, level);
}

int main(int argc, char *argv[]) {
  jmp_state s;
  s.jmp = NULL;

  stack_manipulate_func(&amp;s, 0);

  return 0;
}</code></pre>
</div>


<p>The original gist also comes with logs running this natively or via <code>emscripten</code>. With a stack manipulating setjmp/longjmp, the longjmp would erase the stack for level 1 calling of <code>stack_manipulate_func</code>. The program would only call the exiting printf once. However, with the current implementation of setjmp/longjmp in <code>emscripten</code>, the stack is not changed, the exiting printf will be call by both the level 0 and level 1 version of <code>stack_manipulate_func</code>.</p>

<p>I don&#8217;t think it is very likely that we will have a stack manipulation setjmp/longjmp in JavaScript. So the use of setjmp/longjmp needs to be removed from <code>mruby</code>. But wait, does this sound similar? Didn&#8217;t I just come up with a solution a few days earlier? Well, it is just in my first <a href="http://qiezi.me/blog/2012/11/07/running-mruby-in-a-browser/">post</a> on <code>mruby</code>. I created a <a href="https://github.com/xxuejie/mruby-browser/blob/19365625b1a2e215af69e8196053a17a33bebfed/patches/01-mruby-use-exception.patch">patch</a> to use C++ exception instead of setjmp/longjmp and then found out that our simple <code>main.c</code> file does not need this to run. Well, now we do. So I have to bring <a href="https://github.com/xxuejie/mruby-browser/blob/4a8e43d6ab9fd4c0d86e140f9db316b342c891df/patches/01-use-cpp-exception.patch">it</a> back. This is really bad news for a pathetic C99 lover to find that the dependency for a C++ compiler returns-_-</p>

<p>Quick Update: Actually Alon <a href="https://groups.google.com/forum/?fromgroups=#!topic/emscripten-discuss/Xbu48Tvd2mk">confirms</a> that this is just a bug and it is fixed. So maybe we can still have a C99 solution on this problem. Interesting, I will take a look at this later. I really feel sick about using a C++ compiler, that may bring a lot of evil stuff when working on the later parts involving more C code, such as C function calling interface.</p>

<p>Anyway, now all the tests have passed. Not only in node.js but also in browsers. However, the time to run tests differ greatly:</p>

<ul>
<li>Chrome 23: 1.682s</li>
<li>Firefox Aurora 18: 5.294s</li>
<li>Safari 6: 0.394s</li>
</ul>


<p>This is interesting. Safari is so fast that one can think something went wrong for the other two.</p>

<p>At this time, I believe the testing for mruby in JavaScript has finished. I will spend some time trying to create a irb for the browser and see if I can get it on repl.it. After that I can finally spend the time on C function calling. I wish it could be more fun than debugging the generated JavaScript code-_-</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Running mruby in a browser]]></title>
    <link href="http://xxuejie.github.com/blog/2012/11/07/running-mruby-in-a-browser/"/>
    <updated>2012-11-07T18:08:00-05:00</updated>
    <id>http://xxuejie.github.com/blog/2012/11/07/running-mruby-in-a-browser</id>
    <content type="html"><![CDATA[<p><strong>tl;dr</strong> version: I managed to compile mruby to JavaScript via emscripten, the source code is in a <a href="https://github.com/xxuejie/mruby-browser">Github repository</a>.</p>

<h2>A Little Background</h2>

<p>I really love Ruby, yet I&#8217;m not that much into Rails. Rails is great indeed, I really learned so much while playing around with Rails. In fact, more than half of my knowledge using Ruby was learned reading the Rails source code. However, I just feel bored writing again and again applications working on a database-_- Whatever new features my app has and whatever facinating features Rails provide, basically I just keep writing code to creating entries in db, reading these entries out, updating and deleting them occasionally(Thank you, CRUD!). After all, the MVC architecture is there. It is simply not fun for me>_&lt;</p>

<p>So I always wonder around looking for interesting stuffs outside of the Rails world. <a href="http://celluloid.io/">Celluloid</a>, <a href="http://www.libgosu.org/">Gosu</a>, <a href="http://fluentd.org/">Fluentd</a> are all fun to play with. The latest toy around is <a href="https://github.com/mruby/mruby">mruby</a>, a lightweight implementation Ruby. It works for embedded system and can be linked into existing softwares. Well, that sounds like Lua, but as a former-Lisp fan, Ruby is more interesting, isn&#8217;t it? Sorry I&#8217;ve gone a little off-topic, I could write another post describing my feelings on different languages, but that&#8217;s not the point today:)</p>

<p>Last Saturday I suddenly got such an idea: mruby is light-weighted (around 20,000 lines of code), has a small footprint(~100k according to Matz&#8217;s talk) and no threads. So why not try running it in a browser? Having the experiment of writing Web apps using <a href="https://developers.google.com/web-toolkit/">GWT</a>, I never trust that we must use JavaScript to write code running in a browser. Now that I&#8217;ve got some time, let the fun begin:)</p>

<h2>Building mruby</h2>

<p>Two choices exist to compile C/C++ code into JavaScript: <a href="https://developers.google.com/native-client/">Native Client</a> and <a href="https://github.com/kripken/emscripten">Emscripten</a>. I used to fall in love with everything marked with Google, but things have changed. Let&#8217;s first go with Emscripten and see how everything goes, we have a much larger world of Web instead of Chrome-only kingdoms.</p>

<p>The current <code>mruby</code> compiling process works like this:</p>

<ol>
<li>Use bison to parse <code>src/parse.y</code> into <code>src/y.tab.c</code>.</li>
<li>Compile every <code>c</code> source in <code>src</code>, the generated object files are then archived into <code>lib/libmruby_core.a</code>.</li>
<li>Compile <code>tools/mrbc/mrbc.c</code> and link with <code>lib/libmruby_core.c</code> to generate the core mruby compiler <code>bin/mrbc</code>.</li>
<li>Use the mruby compiler to standard libraries in <code>mrblib</code>, the generated bytecode is attached as an array to <code>mrblib/init_mrblib.c</code>. The newly created source code is called <code>mrblib/mrblib.c</code>.</li>
<li>Compile <code>mrblib/mrblib.c</code> and add to <code>lib/libmruby_core.a</code>. The result is called <code>lib/libmruby.a</code>.</li>
</ol>


<p>We need to compile all source code <code>src</code> together with the generated file <code>src/y.tab.c</code> and <code>mrblib/mrblib.c</code>. For simplicity and the unstable state of mruby, I just require building the entire mruby first in my Makefile:</p>

<div>
  <pre><code class='bash'># mruby settings
MRUBY_PATH := ./modules/mruby
MRBLIB_PATH := $(MRUBY_PATH)/mrblib

MRBLIBC := $(MRBLIB_PATH)/mrblib.c
YC := $(MRUBY_SRC_DIR)/y.tab.c

# yacc compile
$(YC) :
    @(cd $(MRUBY_PATH); make)

# mrblib.c compile
$(MRBLIBC) :
    @(cd $(MRUBY_PATH); make)</code></pre>
</div>


<p>Now the code can be compiled into a giant JavaScript file.</p>

<h2>C compiler vs C++ compiler</h2>

<p>In short, it was a tough and mysterious road-_-</p>

<p>The first version compiles okay, but it keeps running into <code>RangeError: Maximum call stack size exceeded</code> error. While browsing for wiki page of emscripten, one sentence in <a href="https://github.com/kripken/emscripten/wiki/CodeGuidlinesAndLimitations">CodeGuidlinesAndLimitations</a> caught my eye.</p>

<p><em>&#8220;Nonportable code that uses low-level features of the native environment, like native stack manipulation (e.g. in conjunction with setjmp/longjmp. We support normal setjmp/longjmp, but not with stack replacing etc.).&#8221;</em></p>

<p>I suspect this may be the reason, what supports my idea is one <a href="https://github.com/replit/emscripted-ruby/commit/c78f8457817e1fd57f7f464ae9a8158b13dac371">commit</a> in <a href="https://github.com/replit/emscripted-ruby">emscripted-ruby</a>, which is a port for ruby 1.8.7 onto the browser. It basically eliminates all setjmp/longjmp calls with c++ exception. So I decided this may be the direction and started coding right way. Well, now it turns out this is a mistake, I should&#8217;ve done more investigation. Anyway, you will see the mistakes I made.</p>

<p>Then I spent around ten hours figuring out a <a href="https://github.com/xxuejie/mruby-browser/blob/19365625b1a2e215af69e8196053a17a33bebfed/patches/01-mruby-use-exception.patch">way</a> to patch mruby to use c++ exception instead of setjmp/longjmp with all tests passed. The compiler is also changed from <code>emcc</code> to <code>em++</code>. Well, now the mruby compiles and works:</p>

<div>
  <pre><code class='bash'>$ node build/mruby.js
Ruby is awesome!
Ruby is awesome!
Ruby is awesome!
Ruby is awesome!
Ruby is awesome!</code></pre>
</div>


<p>This was Wednesday night and I went to read the FreeBSD book for exam. On Thursday morning, I accidentally compiles the code with <code>em++</code> but without my patches for setjmp. The code happened to work! Even if I revert the code back to the initial revision with all original build settings, I still cannot reproduce the RangeError error. Well, it remains a mystery and all I can guess is that something is wrong with my installation of Node.js at that day. It might use a different setting that day&#8230;</p>

<p>Then another problem came: when compiling with <code>emcc</code>, the code compiles okay, but would run forever without terminating; It would only work when compiling with <code>em++</code>&#8230; This is also strange, I will look into this later.</p>

<p>So the lesson I learned is: do more investigation before pumping out coding. There may be another reason.</p>

<h2>Future Work</h2>

<p>Well, this is really fun. I&#8217;ve sent a post on <a href="https://groups.google.com/forum/?fromgroups=#!topic/emscripten-discuss/DVfjRfOE-z4">emscripten-discuss</a>. And I will spend some time on this.</p>

<p>Besides that, a few interesting follow-up works are already in my head:</p>

<ul>
<li>Interfaces to C and JavaScript libraries</li>
<li>OpenGL ES 2/WebGL binding</li>
<li>Repl in the browser</li>
<li><a href="http://mobiruby.org/">MobiRuby</a> for the browser(well, this may be too ambitious)</li>
</ul>


<p>Anyway, it is really fun working on this.</p>

<h2>Note</h2>

<p>If you read all the way to here(I would not read such a long article myself-_-), I want to say sorry for my English. I&#8217;m only fluent in Chinese, but I just want more people to be able to read about this:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的开始]]></title>
    <link href="http://xxuejie.github.com/blog/2012/10/27/xin-de-kai-shi/"/>
    <updated>2012-10-27T10:06:00-04:00</updated>
    <id>http://xxuejie.github.com/blog/2012/10/27/xin-de-kai-shi</id>
    <content type="html"><![CDATA[<p>从sina到blogpost，再到dreamhost，vps。不知道这是第几个blog了。好久以前看Joel同学的文章说，技术人员应该去写blog。这之后几次跃跃欲试，但是总是有各种理由荒废掉blog。</p>

<p>我希望用这个blog来记录一段新的开始，虽然我依然不确定会不会什么时候荒废掉这里。从今天开始，再不去关心那些无聊的GPA，学校考试考几分的问题。我读本科时曾经证明过一次我可以把GPA刷上去，我不需要再证明一次。我希望把时间用来做更有趣的事情：</p>

<ul>
<li>读更多漂亮有趣的代码</li>
<li>写更多有趣的代码，并争取让这些代码变得漂亮</li>
<li>尽自己的力量为Open Source社区作出贡献</li>
<li>有可能的话，把更多的心得在这里记下来</li>
</ul>


<p>对我而言，写代码是件快乐的事情。我希望找回那种快乐的感觉，而不是关心写实验报告不光放代码还要放截图的问题>_&lt;18个月前我曾经是一个快乐的软件工程师，18个月后，我愿意继续那条路而不是考虑这些无聊的问题。</p>

<p>顺便吐个槽：In theory, there is no difference between theory and practice. But, in practice, there is. 我现在深刻觉得这句话是至理名言。</p>

<p>总之，我不知道这条路我能持续走多久，我也不知道走下去是不是一定会变好，我只知道：</p>

<p>这是条有趣的路~</p>

<p>这就足够了。</p>
]]></content>
  </entry>
  
</feed>
